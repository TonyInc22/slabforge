// prisma/schema.prisma
// SlabForge v1 â€” grading-first card intelligence data model
// Postgres + Prisma Client

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

//
// Enums
//
enum Sport {
  NFL
  NBA
  MLB
  NHL
  NCAA_FOOTBALL
  NCAA_BASKETBALL
  OTHER
}

enum SourceName {
  EBAY
  PSA
  POINT130
  TCGPLAYER
  PANINI
  TOPPS
  OTHER
}

enum ListingStatus {
  ACTIVE
  ENDED
}

//
// Canonical layer (source-agnostic)
//
model CardSet {
  id        String   @id @default(cuid())
  sport     Sport
  year      Int
  brand     String // Panini / Topps
  product   String // Select / Prizm / Donruss Optic
  release   String? // Hobby / Retail / FOTL (optional)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  cards               Card[]
  checklistEntries    ChecklistEntry[]
  parallelDefinitions ParallelDefinition[]

  @@unique([sport, year, brand, product, release])
  @@index([sport, year])
  @@index([brand, product])
}

model Card {
  id         String   @id @default(cuid())
  setId      String
  playerName String
  cardNumber String // supports DT-1, etc.
  team       String?
  rookieYear Int?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  set      CardSet         @relation(fields: [setId], references: [id], onDelete: Cascade)
  variants Variant[]
  setMaps  SetVariantMap[]

  @@unique([setId, cardNumber, playerName])
  @@index([setId])
  @@index([playerName])
  @@index([cardNumber])
}

model Variant {
  id        String   @id @default(cuid())
  cardId    String
  name      String // "Blue Prizm", "Downtown", "Green Shock"
  isInsert  Boolean  @default(false)
  isSerial  Boolean  @default(false)
  printRun  Int? // if known
  serialMax Int? // /5 => 5
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  card      Card                @relation(fields: [cardId], references: [id], onDelete: Cascade)
  popSnaps  PopReportSnapshot[]
  sales     MarketSale[]
  compSnaps CompSnapshot[]
  slabs     SlabbedCard[]

  @@unique([cardId, name, serialMax])
  @@index([cardId])
  @@index([name])
}

model GradingCompany {
  id        String   @id // e.g. "PSA"
  name      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  slabs SlabbedCard[]
}

model SlabbedCard {
  id               String   @id @default(cuid())
  variantId        String
  gradingCompanyId String
  grade            Float // supports 9, 9.5, 10
  certNumber       String? // optional, if you ever ingest cert-level
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  variant        Variant        @relation(fields: [variantId], references: [id], onDelete: Cascade)
  gradingCompany GradingCompany @relation(fields: [gradingCompanyId], references: [id], onDelete: Restrict)

  @@unique([gradingCompanyId, certNumber])
  @@index([variantId, gradingCompanyId, grade])
}

//
// Source registry (optional but nice to keep clean)
//
model Source {
  id        SourceName @id
  name      String
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt
}

//
// eBay layer
//
model EbayListing {
  id                String        @id @default(cuid())
  sourceItemId      String        @unique // eBay itemId
  url               String
  title             String
  condition         String?
  currency          String        @default("USD")
  startPrice        Decimal?      @db.Decimal(12, 2)
  buyItNowPrice     Decimal?      @db.Decimal(12, 2)
  shippingPrice     Decimal?      @db.Decimal(12, 2)
  sellerFeedbackPct Float?
  endTime           DateTime?
  status            ListingStatus @default(ACTIVE)
  rawHash           String? // hash of raw JSON to detect changes
  lastFetchedAt     DateTime?

  // Optional: keep the raw payload for debugging (be mindful of retention)
  rawPayload Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([status, endTime])
  @@index([lastFetchedAt])
}

model MarketSale {
  id            String     @id @default(cuid())
  variantId     String?
  source        SourceName @default(EBAY)
  sourceItemId  String // unique per source
  soldAt        DateTime
  price         Decimal    @db.Decimal(12, 2)
  shipping      Decimal?   @db.Decimal(12, 2)
  totalPrice    Decimal?   @db.Decimal(12, 2) // store if you precompute; otherwise compute in code
  currency      String     @default("USD")
  titleSnapshot String
  gradeDetected String? // "PSA 10", etc.
  confidence    Float      @default(0) // 0..1 matching confidence

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  variant Variant? @relation(fields: [variantId], references: [id], onDelete: SetNull)

  @@unique([source, sourceItemId])
  @@index([variantId, soldAt(sort: Desc)])
  @@index([soldAt(sort: Desc)])
  @@index([source, soldAt(sort: Desc)])
}

model QueryCache {
  id        String     @id @default(cuid())
  source    SourceName
  queryKey  String // hash of params
  payload   Json
  expiresAt DateTime
  createdAt DateTime   @default(now())

  @@unique([source, queryKey])
  @@index([expiresAt])
}

//
// PSA Pop Reports (snapshot-based)
//
model PopReportSnapshot {
  id          String     @id @default(cuid())
  variantId   String
  asOfDate    DateTime   @db.Date
  totalGraded Int
  byGrade     Json // ex: { "10": 42, "9": 180, "8": 60 }
  source      SourceName @default(PSA)
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt

  variant Variant @relation(fields: [variantId], references: [id], onDelete: Cascade)

  @@unique([variantId, asOfDate])
  @@index([variantId, asOfDate(sort: Desc)])
}

//
// Checklist + parallel definitions (Panini/Topps or curated)
//
model ChecklistEntry {
  id         String   @id @default(cuid())
  setId      String
  cardNumber String
  playerName String
  team       String?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  set CardSet @relation(fields: [setId], references: [id], onDelete: Cascade)

  @@unique([setId, cardNumber, playerName])
  @@index([setId])
  @@index([playerName])
}

model ParallelDefinition {
  id         String   @id @default(cuid())
  setId      String
  name       String // "Gold /10", "Black 1/1"
  serialMax  Int?
  rarityTier String? // "common/rare/ultra" (optional)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  set  CardSet         @relation(fields: [setId], references: [id], onDelete: Cascade)
  maps SetVariantMap[]

  @@unique([setId, name, serialMax])
  @@index([setId])
  @@index([name])
}

model SetVariantMap {
  id                   String @id @default(cuid())
  cardId               String
  parallelDefinitionId String

  card               Card               @relation(fields: [cardId], references: [id], onDelete: Cascade)
  parallelDefinition ParallelDefinition @relation(fields: [parallelDefinitionId], references: [id], onDelete: Cascade)

  @@unique([cardId, parallelDefinitionId])
  @@index([parallelDefinitionId])
}

//
// 130point (or other comp validation) snapshots
//
model CompSnapshot {
  id         String     @id @default(cuid())
  variantId  String?
  source     SourceName @default(POINT130)
  observedAt DateTime
  compCount  Int?
  median     Decimal?   @db.Decimal(12, 2)
  mean       Decimal?   @db.Decimal(12, 2)
  p10        Decimal?   @db.Decimal(12, 2)
  p90        Decimal?   @db.Decimal(12, 2)
  payload    Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  variant Variant? @relation(fields: [variantId], references: [id], onDelete: SetNull)

  @@index([variantId, observedAt(sort: Desc)])
  @@index([observedAt(sort: Desc)])
  @@index([source, observedAt(sort: Desc)])
}
